{
  "HomePage": {
    "title": "Rubén Hernández Acevedo",
    "subtitle": "全栈开发者 | 应用、网站和人工智能",
    "description": "专注于移动应用开发、现代网页解决方案和人工智能系统。我将创意转化为创新的数字体验。"
  },
  "Navigation": {
    "home": "首页",
    "about": "关于",
    "projects": "项目",
    "contact": "联系"
  },
  "Language": {
    "switch": "切换语言",
    "selectLanguage": "选择语言",
    "spanish": "西班牙语",
    "english": "英语",
    "french": "法语",
    "portuguese": "葡萄牙语",
    "italian": "意大利语",
    "chinese": "中文"
  },
  "Loader": {
    "loading": "加载中..."
  },
  "Projects": {
    "title": "已完成项目",
    "subtitle": "探索我开发的一些最杰出的项目，从网页应用到企业解决方案。",
    "suncar": {
      "title": "SunCar",
      "description": "光伏安装公司。为家庭和企业提供创新的太阳能解决方案。"
    },
    "playup": {
      "title": "Playup",
      "description": "国际业余足球锦标赛、球员和团队管理。完整的体育平台。"
    },
    "moneyapp": {
      "title": "MoneyApp",
      "description": "具有人工智能的个人理财助手。智能和自动化地管理您的财务。"
    },
    "solarsurvivor": {
      "title": "Solar Survivor",
      "description": "太阳能模拟游戏。使用可持续的光伏技术生存和繁荣。"
    },
    "fintech": {
      "title": "金融科技平台",
      "description": "具有高级数据分析和实时仪表板的企业金融平台，用于投资组合管理。"
    }
  },
  "TerminalSection": {
    "title": "配置环境",
    "description": "安装能够产生差异的专业技能。",
    "success": "全栈开发者已准备好投入生产 ✨",
    "footer": "软件开发就像解决复杂的谜题：每一行代码都很重要。"
  },
  "ResponsiveSection": {
    "title": "响应式设计",
    "description": "我开发的每个项目都经过优化，可以在任何设备上完美运行，从移动设备到桌面。",
    "footer": "无论从哪个屏幕访问，用户体验都是一致的。"
  },
  "TabsSection": {
    "title": "我最喜欢的技术栈",
    "description": "如果我必须选择一个最喜欢的技术栈来开发完整项目，这将是我创建强大和可扩展解决方案的理想武器库。",
    "fastapi": {
      "description": "现代快速的Python框架，用于构建具有自动文档和类型验证的强大API。"
    },
    "nextjs": {
      "description": "生产就绪的React框架，具有混合渲染、自动优化和卓越的开发体验。"
    },
    "mongodb": {
      "description": "可扩展且灵活的NoSQL数据库，可以高效处理具有动态模式的大量数据。"
    },
    "kotlin": {
      "description": "用于原生Android开发的现代语言，具有简洁语法和Java互操作性。"
    },
    "swift": {
      "description": "Apple强大而直观的语言，用于创建高性能的原生iOS应用程序。"
    },
    "railway": {
      "description": "现代部署平台，通过自动CI/CD简化应用程序托管。"
    },
    "figma": {
      "description": "协作设计工具，用于创建专业的用户界面和交互式原型。"
    },
    "claude": {
      "description": "开发AI助手，通过智能建议和代码生成加速编程。"
    }
  },
  "Technologies": {
    "title": "技术技能",
    "description": "我的经验范围从UX/UI设计到基础设施，使我能够以全面的开发视野领导端到端项目。",
    "techCount": "技术",
    "yearsExp": "年经验",
    "additionalInfo": "我的技术栈不断发展，始终探索新工具，让我能够创造更好的解决方案，并紧跟开发的最新趋势。",
    "centerText": "技术栈",
    "frontend": {
      "title": "前端",
      "description": "使用React、Vue、Next.js构建现代响应式界面，提供卓越的用户体验。"
    },
    "backend": {
      "title": "后端",
      "description": "使用Laravel、FastAPI、Python构建强大可扩展的API，用于可靠的企业系统。"
    },
    "mobile": {
      "title": "移动端",
      "description": "使用Kotlin、Swift进行原生开发，使用Web技术进行跨平台开发，创建高性能移动应用。"
    }
  },
  "ContactSection": {
    "title": "联系我",
    "description": "有项目想法或想要合作？我很乐意听到您的想法并帮助您将其变为现实。",
    "availableTitle": "项目可用",
    "availableDescription": "我目前接受新项目和合作。请随时联系我讨论您的下一个开发项目。"
  },
  "Actions": {
    "downloadCV": "下载简历",
    "viewGitHub": "查看GitHub"
  },
  "CVDialog": {
    "title": "简历暂不可用",
    "description": "您好！我的简历暂时无法下载，但很快就会提供。请您稍后再来获取。",
    "actionText": "了解",
    "close": "关闭"
  },
  "BestPractices": {
    "title": "开发最佳实践",
    "subtitle": "我在项目中应用的SOLID原则、整洁代码、安全性和性能实践的真实示例，用于创建可维护和可扩展的代码。",
    "description": "这些实践确保代码易于维护、测试和扩展，从而产生更强大的应用程序和更高效的开发团队。",
    "practices": "原则",
    "selectFile": "选择文件查看示例",
    "files": {
      "singleResponsibility": "单一职责原则.ts",
      "openClosed": "开闭原则.ts", 
      "dependencyInversion": "依赖倒置原则.ts",
      "meaningfulNames": "有意义的命名.ts",
      "smallFunctions": "小函数.ts",
      "avoidComments": "自文档代码.ts",
      "inputValidation": "输入验证.ts",
      "secureSecrets": "安全密钥管理.ts",
      "avoidNPlusOne": "避免N加一查询.ts",
      "efficientCaching": "高效缓存.ts"
    },
    "examples": {
      "single-responsibility": {
        "title": "单一职责原则",
        "description": "每个类应该只有一个改变的理由。我们将职责分离到专门的类中。"
      },
      "open-closed": {
        "title": "开闭原则",
        "description": "实体应该对扩展开放，对修改关闭。我们使用抽象来实现新功能。"
      },
      "dependency-inversion": {
        "title": "依赖倒置原则",
        "description": "我们依赖于抽象，而不是具体实现。这便于测试和提供灵活性。"
      },
      "meaningful-names": {
        "title": "有意义的命名",
        "description": "使用描述性和清晰的名称来表达代码的意图，消除对解释性注释的需要。"
      },
      "small-functions": {
        "title": "小函数",
        "description": "将大函数分解为小的、专门的函数，有效地执行单一任务。"
      },
      "avoid-comments": {
        "title": "自文档代码",
        "description": "编写通过清晰的名称和逻辑结构自我解释的代码，最小化注释。"
      },
      "input-validation": {
        "title": "输入验证",
        "description": "实施严格的输入数据验证和清理，以防止安全漏洞。"
      },
      "secure-secrets": {
        "title": "安全密钥管理",
        "description": "使用环境变量和专门服务安全地处理凭据和密钥。"
      },
      "avoid-n-plus-1": {
        "title": "避免N+1查询",
        "description": "优化数据库查询以避免N+1问题，使用高效的连接和包含。"
      },
      "efficient-caching": {
        "title": "高效缓存",
        "description": "实施智能缓存策略以提高性能并减少数据库负载。"
      }
    }
  },
  "CodeExamples": {
    "singleResponsibility": {
      "before": "// ❌ 违反单一职责原则\nclass UserService {\n  async createUser(userData: any) {\n    // 验证\n    if (!userData.email || !userData.password) {\n      throw new Error('Email and password are required');\n    }\n    \n    // 发送邮件\n    await this.sendWelcomeEmail(userData.email);\n    \n    // 数据库保存\n    const user = await db.users.create(userData);\n    \n    // 日志记录\n    console.log(`User created: ${user.id}`);\n    \n    return user;\n  }\n  \n  private async sendWelcomeEmail(email: string) {\n    // 邮件发送逻辑\n  }\n}",
      "after": "// ✅ 遵循单一职责原则\nclass UserService {\n  constructor(\n    private validator: UserValidator, // [!code ++]\n    private emailService: EmailService, // [!code ++]\n    private userRepository: UserRepository, // [!code ++]\n    private logger: Logger // [!code ++]\n  ) {}\n\n  async createUser(userData: any): Promise<User> {\n    this.validator.validate(userData); // [!code focus]\n    \n    const user = await this.userRepository.create(userData); // [!code focus]\n    \n    await this.emailService.sendWelcomeEmail(user.email); // [!code focus]\n    this.logger.log(`User created: ${user.id}`); // [!code focus]\n    \n    return user;\n  }\n}\n\nclass UserValidator { // [!code ++]\n  validate(userData: any): void { // [!code ++]\n    if (!userData.email || !userData.password) { // [!code ++]\n      throw new Error('Email and password are required'); // [!code ++]\n    } // [!code ++]\n  } // [!code ++]\n} // [!code ++]"
    },
    "openClosed": {
      "before": "// ❌ 违反开闭原则\nclass PaymentProcessor {\n  processPayment(amount: number, method: string) {\n    if (method === 'credit-card') {\n      return this.processCreditCard(amount);\n    } else if (method === 'paypal') {\n      return this.processPaypal(amount);\n    } else if (method === 'bank-transfer') {\n      return this.processBankTransfer(amount);\n    }\n    throw new Error('Unsupported payment method');\n  }\n  \n  private processCreditCard(amount: number) {\n    // 信用卡逻辑\n  }\n  \n  private processPaypal(amount: number) {\n    // PayPal逻辑\n  }\n  \n  private processBankTransfer(amount: number) {\n    // 银行转账逻辑\n  }\n}",
      "after": "// ✅ 遵循开闭原则\ninterface PaymentMethod { // [!code ++]\n  process(amount: number): Promise<PaymentResult>; // [!code ++]\n} // [!code ++]\n\nclass CreditCardPayment implements PaymentMethod { // [!code ++]\n  async process(amount: number): Promise<PaymentResult> { // [!code ++]\n    // 信用卡特定逻辑 // [!code ++]\n    return { success: true, transactionId: 'cc_123' }; // [!code ++]\n  } // [!code ++]\n} // [!code ++]\n\nclass PaypalPayment implements PaymentMethod { // [!code ++]\n  async process(amount: number): Promise<PaymentResult> { // [!code ++]\n    // PayPal特定逻辑 // [!code ++]\n    return { success: true, transactionId: 'pp_456' }; // [!code ++]\n  } // [!code ++]\n} // [!code ++]\n\nclass PaymentProcessor {\n  constructor(private paymentMethod: PaymentMethod) {} // [!code focus]\n  \n  async processPayment(amount: number): Promise<PaymentResult> { // [!code focus]\n    return await this.paymentMethod.process(amount); // [!code focus]\n  } // [!code focus]\n}"
    },
    "dependencyInversion": {
      "before": "// ❌ 违反依赖倒置原则\nimport { MySQLDatabase } from './MySQLDatabase';\nimport { EmailProvider } from './EmailProvider';\n\nclass OrderService {\n  private database: MySQLDatabase;\n  private emailProvider: EmailProvider;\n  \n  constructor() {\n    this.database = new MySQLDatabase(); // 直接依赖\n    this.emailProvider = new EmailProvider(); // 直接依赖\n  }\n  \n  async createOrder(orderData: any) {\n    const order = await this.database.save(orderData);\n    await this.emailProvider.sendConfirmation(order.customerEmail);\n    return order;\n  }\n}",
      "after": "// ✅ 遵循依赖倒置原则\ninterface Database { // [!code ++]\n  save(data: any): Promise<any>; // [!code ++]\n} // [!code ++]\n\ninterface NotificationService { // [!code ++]\n  sendConfirmation(email: string): Promise<void>; // [!code ++]\n} // [!code ++]\n\nclass OrderService {\n  constructor(\n    private database: Database, // 抽象 // [!code focus]\n    private notificationService: NotificationService // 抽象 // [!code focus]\n  ) {}\n  \n  async createOrder(orderData: any) {\n    const order = await this.database.save(orderData); // [!code focus]\n    await this.notificationService.sendConfirmation(order.customerEmail); // [!code focus]\n    return order;\n  }\n}\n\n// 具体实现 // [!code ++]\nclass MySQLDatabase implements Database { // [!code ++]\n  async save(data: any): Promise<any> { // [!code ++]\n    // MySQL特定实现 // [!code ++]\n  } // [!code ++]\n} // [!code ++]\n\nclass EmailNotificationService implements NotificationService { // [!code ++]\n  async sendConfirmation(email: string): Promise<void> { // [!code ++]\n    // 邮件特定实现 // [!code ++]\n  } // [!code ++]\n} // [!code ++]"
    },
    "meaningfulNames": {
      "before": "// ❌ 非描述性命名\nclass Calc {\n  private data: any[] = [];\n  \n  process(d: any): number {\n    let r = 0;\n    let t = 0;\n    \n    for (let i = 0; i < d.length; i++) {\n      if (d[i].type === 1) {\n        r += d[i].amt * d[i].qty;\n        t += d[i].amt * d[i].qty * 0.15;\n      }\n    }\n    \n    return r + t;\n  }\n  \n  validate(x: any): boolean {\n    return x && x.amt > 0 && x.qty > 0;\n  }\n}",
      "after": "// ✅ 描述性和有意义的命名\nclass ProductPriceCalculator { // [!code ++]\n  private products: Product[] = []; // [!code ++]\n  \n  calculateTotalPrice(products: Product[]): number { // [!code ++]\n    let subtotal = 0; // [!code ++]\n    let taxes = 0; // [!code ++]\n    \n    for (const product of products) { // [!code ++]\n      if (product.isActive) { // [!code ++]\n        const itemTotal = product.price * product.quantity; // [!code ++]\n        subtotal += itemTotal; // [!code ++]\n        taxes += itemTotal * TAX_RATE; // [!code ++]\n      } // [!code ++]\n    } // [!code ++]\n    \n    return subtotal + taxes; // [!code ++]\n  } // [!code ++]\n  \n  isValidProduct(product: Product): boolean { // [!code ++]\n    return product && product.price > 0 && product.quantity > 0; // [!code ++]\n  } // [!code ++]\n} // [!code ++]\n\nconst TAX_RATE = 0.15; // [!code ++]\n\ninterface Product { // [!code ++]\n  price: number; // [!code ++]\n  quantity: number; // [!code ++]\n  isActive: boolean; // [!code ++]\n} // [!code ++]"
    },
    "smallFunctions": {
      "before": "// ❌ 做太多事情的大函数\nasync function registerUser(userData: any) {\n  // 验证\n  if (!userData.email || !userData.email.includes('@')) {\n    throw new Error('Invalid email');\n  }\n  if (!userData.password || userData.password.length < 8) {\n    throw new Error('Password too short');\n  }\n  if (!userData.name || userData.name.trim().length === 0) {\n    throw new Error('Name is required');\n  }\n  \n  // 密码哈希\n  const salt = await bcrypt.genSalt(10);\n  const hashedPassword = await bcrypt.hash(userData.password, salt);\n  \n  // 创建用户\n  const user = await db.users.create({\n    email: userData.email.toLowerCase(),\n    password: hashedPassword,\n    name: userData.name.trim(),\n    createdAt: new Date()\n  });\n  \n  // 发送欢迎邮件\n  const emailTemplate = `欢迎 ${user.name}! 感谢您加入我们。`;\n  await emailService.send(user.email, '欢迎!', emailTemplate);\n  \n  // 记录活动\n  await db.logs.create({\n    action: 'USER_REGISTERED',\n    userId: user.id,\n    timestamp: new Date()\n  });\n  \n  return user;\n}",
      "after": "// ✅ 具有特定职责的小函数\nasync function registerUser(userData: UserRegistrationData): Promise<User> {\n  await validateUserData(userData); // [!code focus]\n  \n  const hashedPassword = await hashPassword(userData.password); // [!code focus]\n  const user = await createUser(userData, hashedPassword); // [!code focus]\n  \n  await sendWelcomeEmail(user); // [!code focus]\n  await logUserRegistration(user.id); // [!code focus]\n  \n  return user;\n}\n\nasync function validateUserData(userData: UserRegistrationData): Promise<void> { // [!code ++]\n  validateEmail(userData.email); // [!code ++]\n  validatePassword(userData.password); // [!code ++]\n  validateName(userData.name); // [!code ++]\n} // [!code ++]\n\nfunction validateEmail(email: string): void { // [!code ++]\n  if (!email || !email.includes('@')) { // [!code ++]\n    throw new Error('Invalid email'); // [!code ++]\n  } // [!code ++]\n} // [!code ++]\n\nasync function hashPassword(password: string): Promise<string> { // [!code ++]\n  const salt = await bcrypt.genSalt(10); // [!code ++]\n  return bcrypt.hash(password, salt); // [!code ++]\n} // [!code ++]\n\nasync function createUser(userData: UserRegistrationData, hashedPassword: string): Promise<User> { // [!code ++]\n  return db.users.create({ // [!code ++]\n    email: userData.email.toLowerCase(), // [!code ++]\n    password: hashedPassword, // [!code ++]\n    name: userData.name.trim(), // [!code ++]\n    createdAt: new Date() // [!code ++]\n  }); // [!code ++]\n} // [!code ++]"
    },
    "avoidComments": {
      "before": "// ❌ 需要大量注释才能理解的代码\nclass InventoryManager {\n  // 检查产品是否可用\n  check(p: Product, q: number): boolean {\n    // 获取当前库存水平\n    const s = this.getStock(p.id);\n    \n    // 检查是否有足够的库存\n    // 还需要考虑预留物品\n    const r = this.getReserved(p.id);\n    \n    // 可用 = 库存 - 预留\n    const a = s - r;\n    \n    // 如果有足够数量则返回true\n    return a >= q;\n  }\n  \n  // 下订单时更新库存\n  update(pid: number, qty: number) {\n    // 获取当前值\n    const current = this.inventory[pid];\n    \n    // 减去数量\n    current.stock -= qty;\n    \n    // 添加到预留\n    current.reserved += qty;\n    \n    // 更新时间戳\n    current.lastUpdated = Date.now();\n  }\n}",
      "after": "// ✅ 无需注释的自文档代码\nclass InventoryManager {\n  isProductAvailable(product: Product, requestedQuantity: number): boolean { // [!code ++]\n    const currentStock = this.getCurrentStock(product.id); // [!code ++]\n    const reservedQuantity = this.getReservedQuantity(product.id); // [!code ++]\n    const availableQuantity = currentStock - reservedQuantity; // [!code ++]\n    \n    return availableQuantity >= requestedQuantity; // [!code ++]\n  } // [!code ++]\n  \n  reserveProductForOrder(productId: number, quantity: number): void { // [!code ++]\n    const inventoryRecord = this.getInventoryRecord(productId); // [!code ++]\n    \n    inventoryRecord.decreaseStock(quantity); // [!code ++]\n    inventoryRecord.increaseReserved(quantity); // [!code ++]\n    inventoryRecord.updateTimestamp(); // [!code ++]\n  } // [!code ++]\n  \n  private getCurrentStock(productId: number): number { // [!code ++]\n    return this.inventory[productId]?.stock ?? 0; // [!code ++]\n  } // [!code ++]\n  \n  private getReservedQuantity(productId: number): number { // [!code ++]\n    return this.inventory[productId]?.reserved ?? 0; // [!code ++]\n  } // [!code ++]\n  \n  private getInventoryRecord(productId: number): InventoryRecord { // [!code ++]\n    return this.inventory[productId]; // [!code ++]\n  } // [!code ++]\n}"
    },
    "inputValidation": {
      "before": "// ❌ 无输入验证 - 易受攻击\nclass AuthController {\n  async login(req: any, res: any) {\n    const { email, password } = req.body;\n    \n    // 直接搜索用户，无验证\n    const user = await db.query(\n      `SELECT * FROM users WHERE email = '${email}'`\n    );\n    \n    // 比较明文密码\n    if (user && user.password === password) {\n      // 无验证创建令牌\n      const token = jwt.sign({ id: user.id }, 'secret');\n      \n      res.json({ token, user });\n    } else {\n      res.status(401).json({ error: 'Invalid credentials' });\n    }\n  }\n  \n  async updateProfile(req: any, res: any) {\n    const { name, bio } = req.body;\n    \n    // 无清理直接更新\n    await db.query(\n      `UPDATE users SET name = '${name}', bio = '${bio}' WHERE id = ${req.user.id}`\n    );\n    \n    res.json({ success: true });\n  }\n}",
      "after": "// ✅ 具有适当验证和清理的代码\nclass AuthController {\n  async login(req: Request, res: Response) { // [!code ++]\n    const { email, password } = this.validateLoginInput(req.body); // [!code ++]\n    \n    const user = await this.userRepository.findByEmail(email); // [!code ++]\n    \n    if (!user || !await this.passwordService.verify(password, user.hashedPassword)) { // [!code ++]\n      throw new UnauthorizedError('Invalid credentials'); // [!code ++]\n    } // [!code ++]\n    \n    const token = this.tokenService.generateSecureToken(user.id); // [!code ++]\n    \n    res.json({ // [!code ++]\n      token, // [!code ++]\n      user: this.sanitizeUserData(user) // [!code ++]\n    }); // [!code ++]\n  } // [!code ++]\n  \n  async updateProfile(req: Request, res: Response) { // [!code ++]\n    const userId = this.validateUserId(req.user.id); // [!code ++]\n    const { name, bio } = this.validateProfileInput(req.body); // [!code ++]\n    \n    const sanitizedData = { // [!code ++]\n      name: this.sanitizer.cleanString(name), // [!code ++]\n      bio: this.sanitizer.cleanString(bio) // [!code ++]\n    }; // [!code ++]\n    \n    await this.userRepository.updateProfile(userId, sanitizedData); // [!code ++]\n    \n    res.json({ success: true }); // [!code ++]\n  } // [!code ++]\n  \n  private validateLoginInput(body: any): LoginData { // [!code ++]\n    const schema = z.object({ // [!code ++]\n      email: z.string().email().max(255), // [!code ++]\n      password: z.string().min(8).max(128) // [!code ++]\n    }); // [!code ++]\n    \n    return schema.parse(body); // [!code ++]\n  } // [!code ++]\n}"
    },
    "secureSecrets": {
      "before": "// ❌ 硬编码和暴露的密钥\nclass DatabaseConfig {\n  private connectionString = \"postgresql://admin:password123@localhost:5432/mydb\";\n  \n  private jwtSecret = \"my-super-secret-key\";\n  \n  private apiKeys = {\n    stripe: \"sk_live_abc123def456ghi789\",\n    sendgrid: \"SG.xyz789.abc123def456\",\n    aws: \"AKIAIOSFODNN7EXAMPLE\"\n  };\n  \n  async connect() {\n    console.log(\"连接到:\", this.connectionString);\n    return pg.connect(this.connectionString);\n  }\n  \n  generateToken(payload: any) {\n    return jwt.sign(payload, this.jwtSecret, { expiresIn: '24h' });\n  }\n  \n  async sendEmail(to: string, subject: string, body: string) {\n    const client = new SendGrid(this.apiKeys.sendgrid);\n    return client.send({ to, subject, body });\n  }\n}",
      "after": "// ✅ 使用环境变量的安全密钥管理\nclass DatabaseConfig {\n  private readonly connectionString: string; // [!code ++]\n  private readonly jwtSecret: string; // [!code ++]\n  private readonly apiKeys: ApiKeys; // [!code ++]\n  \n  constructor() { // [!code ++]\n    this.validateEnvironment(); // [!code ++]\n    \n    this.connectionString = this.buildConnectionString(); // [!code ++]\n    this.jwtSecret = this.getRequiredEnvVar('JWT_SECRET'); // [!code ++]\n    this.apiKeys = this.loadApiKeys(); // [!code ++]\n  } // [!code ++]\n  \n  async connect(): Promise<pg.Client> { // [!code ++]\n    return pg.connect(this.connectionString); // [!code ++]\n  } // [!code ++]\n  \n  generateToken(payload: any): string { // [!code ++]\n    if (!this.jwtSecret) { // [!code ++]\n      throw new Error('JWT secret not configured'); // [!code ++]\n    } // [!code ++]\n    \n    return jwt.sign(payload, this.jwtSecret, { expiresIn: '24h' }); // [!code ++]\n  } // [!code ++]\n  \n  private buildConnectionString(): string { // [!code ++]\n    const host = this.getRequiredEnvVar('DB_HOST'); // [!code ++]\n    const port = this.getRequiredEnvVar('DB_PORT'); // [!code ++]\n    const database = this.getRequiredEnvVar('DB_NAME'); // [!code ++]\n    const username = this.getRequiredEnvVar('DB_USER'); // [!code ++]\n    const password = this.getRequiredEnvVar('DB_PASSWORD'); // [!code ++]\n    \n    return `postgresql://${username}:${password}@${host}:${port}/${database}`; // [!code ++]\n  } // [!code ++]\n  \n  private getRequiredEnvVar(name: string): string { // [!code ++]\n    const value = process.env[name]; // [!code ++]\n    if (!value) { // [!code ++]\n      throw new Error(`缺少必需的环境变量: ${name}`); // [!code ++]\n    } // [!code ++]\n    return value; // [!code ++]\n  } // [!code ++]\n}"
    },
    "avoidNPlusOne": {
      "before": "// ❌ N+1问题：每个帖子一个查询\nclass PostService {\n  async getPostsWithAuthors(): Promise<PostWithAuthor[]> {\n    const posts = await db.posts.findMany({\n      where: { published: true },\n      orderBy: { createdAt: 'desc' }\n    });\n    \n    // N+1问题！每个帖子一个查询\n    const postsWithAuthors = [];\n    for (const post of posts) {\n      const author = await db.users.findUnique({\n        where: { id: post.authorId },\n        select: { id: true, name: true, email: true }\n      });\n      \n      postsWithAuthors.push({\n        ...post,\n        author\n      });\n    }\n    \n    return postsWithAuthors;\n  }\n  \n  async getPostsWithComments(): Promise<PostWithComments[]> {\n    const posts = await db.posts.findMany();\n    \n    // 评论又是N+1问题\n    for (const post of posts) {\n      post.comments = await db.comments.findMany({\n        where: { postId: post.id }\n      });\n    }\n    \n    return posts;\n  }\n}",
      "after": "// ✅ 使用连接/包含的优化查询\nclass PostService {\n  async getPostsWithAuthors(): Promise<PostWithAuthor[]> { // [!code ++]\n    return db.posts.findMany({ // [!code ++]\n      where: { published: true }, // [!code ++]\n      orderBy: { createdAt: 'desc' }, // [!code ++]\n      include: { // [!code focus]\n        author: { // [!code focus]\n          select: { // [!code focus]\n            id: true, // [!code focus]\n            name: true, // [!code focus]\n            email: true // [!code focus]\n          } // [!code focus]\n        } // [!code focus]\n      } // [!code focus]\n    }); // [!code ++]\n  } // [!code ++]\n  \n  async getPostsWithComments(): Promise<PostWithComments[]> { // [!code ++]\n    return db.posts.findMany({ // [!code ++]\n      include: { // [!code focus]\n        author: { // [!code focus]\n          select: { id: true, name: true } // [!code focus]\n        }, // [!code focus]\n        comments: { // [!code focus]\n          include: { // [!code focus]\n            author: { // [!code focus]\n              select: { id: true, name: true } // [!code focus]\n            } // [!code focus]\n          } // [!code focus]\n        } // [!code focus]\n      } // [!code focus]\n    }); // [!code ++]\n  } // [!code ++]\n  \n  async getPostsWithStats(): Promise<PostWithStats[]> { // [!code ++]\n    return db.posts.findMany({ // [!code ++]\n      include: { // [!code ++]\n        _count: { // [!code focus]\n          select: { // [!code focus]\n            comments: true, // [!code focus]\n            likes: true // [!code focus]\n          } // [!code focus]\n        } // [!code focus]\n      } // [!code ++]\n    }); // [!code ++]\n  } // [!code ++]\n}"
    },
    "efficientCaching": {
      "before": "// ❌ 无缓存 - 重复昂贵查询\nclass ProductService {\n  async getProduct(id: number): Promise<Product> {\n    // 总是访问数据库\n    const product = await db.products.findUnique({\n      where: { id },\n      include: {\n        category: true,\n        reviews: {\n          include: { user: true }\n        },\n        variants: true\n      }\n    });\n    \n    if (!product) {\n      throw new Error('Product not found');\n    }\n    \n    // 重复的昂贵计算\n    const averageRating = product.reviews.reduce((sum, review) => \n      sum + review.rating, 0) / product.reviews.length;\n    \n    const totalStock = product.variants.reduce((sum, variant) => \n      sum + variant.stock, 0);\n    \n    return {\n      ...product,\n      averageRating,\n      totalStock,\n      isAvailable: totalStock > 0\n    };\n  }\n  \n  async getPopularProducts(): Promise<Product[]> {\n    // 无缓存的重查询\n    return db.products.findMany({\n      where: { featured: true },\n      include: { reviews: true, category: true },\n      orderBy: { viewCount: 'desc' },\n      take: 10\n    });\n  }\n}",
      "after": "// ✅ 智能分层缓存\nclass ProductService {\n  constructor( // [!code ++]\n    private cache: CacheService, // [!code ++]\n    private db: DatabaseService // [!code ++]\n  ) {} // [!code ++]\n  \n  async getProduct(id: number): Promise<Product> { // [!code ++]\n    const cacheKey = `product:${id}`; // [!code ++]\n    \n    let product = await this.cache.get<Product>(cacheKey); // [!code focus]\n    if (product) { // [!code focus]\n      return product; // [!code focus]\n    } // [!code focus]\n    \n    product = await this.fetchProductWithCalculations(id); // [!code ++]\n    \n    await this.cache.set(cacheKey, product, { // [!code focus]\n      ttl: 3600, // 1小时 // [!code focus]\n      tags: ['product', `product-${id}`] // [!code focus]\n    }); // [!code focus]\n    \n    return product; // [!code ++]\n  } // [!code ++]\n  \n  async getPopularProducts(): Promise<Product[]> { // [!code ++]\n    const cacheKey = 'products:popular'; // [!code ++]\n    \n    let products = await this.cache.get<Product[]>(cacheKey); // [!code focus]\n    if (products) { // [!code focus]\n      return products; // [!code focus]\n    } // [!code focus]\n    \n    products = await this.db.products.findMany({ // [!code ++]\n      where: { featured: true }, // [!code ++]\n      include: { category: true }, // [!code ++]\n      orderBy: { viewCount: 'desc' }, // [!code ++]\n      take: 10 // [!code ++]\n    }); // [!code ++]\n    \n    await this.cache.set(cacheKey, products, { // [!code focus]\n      ttl: 1800, // 30分钟 // [!code focus]\n      tags: ['products', 'popular'] // [!code focus]\n    }); // [!code focus]\n    \n    return products; // [!code ++]\n  } // [!code ++]\n  \n  async invalidateProductCache(productId: number): Promise<void> { // [!code ++]\n    await this.cache.invalidateByTags([`product-${productId}`, 'popular']); // [!code ++]\n  } // [!code ++]\n}"
    }
  }
}