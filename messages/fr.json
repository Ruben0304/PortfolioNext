{
  "HomePage": {
    "title": "Rubén Hernández Acevedo",
    "subtitle": "Développeur Full Stack | Apps, Web et IA",
    "description": "Spécialisé dans le développement d'applications mobiles, de solutions web modernes et de systèmes d'intelligence artificielle. Je transforme les idées en expériences numériques innovantes."
  },
  "Navigation": {
    "home": "Accueil",
    "about": "À propos",
    "projects": "Projets",
    "contact": "Contact"
  },
  "Language": {
    "switch": "Changer de langue",
    "selectLanguage": "Sélectionner la langue",
    "spanish": "Espagnol",
    "english": "Anglais",
    "french": "Français",
    "portuguese": "Portugais",
    "italian": "Italien",
    "chinese": "中文"
  },
  "Loader": {
    "loading": "Chargement..."
  },
  "Projects": {
    "title": "Projets Réalisés",
    "subtitle": "Explorez certains des projets les plus remarquables que j'ai développés, des applications web aux solutions d'entreprise.",
    "suncar": {
      "title": "SunCar",
      "description": "Entreprise d'installations photovoltaïques. Solutions innovantes en énergie solaire pour les maisons et entreprises."
    },
    "playup": {
      "title": "Playup",
      "description": "Gestion de tournois, joueurs et équipes de football amateur international. Plateforme sportive complète."
    },
    "moneyapp": {
      "title": "MoneyApp",
      "description": "Assistant de finances personnelles avec IA. Gérez vos finances de manière intelligente et automatisée."
    },
    "solarsurvivor": {
      "title": "Solar Survivor",
      "description": "Jeu de simulation d'énergie solaire. Survivez et prospérez en utilisant la technologie photovoltaïque durable."
    },
    "fintech": {
      "title": "Plateforme FinTech",
      "description": "Plateforme financière d'entreprise avec analyse avancée de données et tableau de bord en temps réel pour la gestion de portefeuilles."
    }
  },
  "TerminalSection": {
    "title": "Configuration de l'Environnement",
    "description": "Installation des compétences professionnelles qui font la différence.",
    "success": "Développeur full-stack prêt pour la production ✨",
    "footer": "Le développement logiciel, c'est comme résoudre des puzzles complexes : chaque ligne de code compte."
  },
  "ResponsiveSection": {
    "title": "Design Responsive",
    "description": "Chaque projet que je développe est optimisé pour fonctionner parfaitement sur tout appareil, du mobile au desktop.",
    "footer": "L'expérience utilisateur est cohérente peu importe l'écran depuis lequel on accède."
  },
  "TabsSection": {
    "title": "Ma Stack Technologique Préférée",
    "description": "Si je devais choisir une stack technologique préférée pour développer un projet complet, ce serait mon arsenal idéal pour créer des solutions robustes et évolutives.",
    "fastapi": {
      "description": "Framework Python moderne et rapide pour créer des APIs robustes avec documentation automatique et validation de types."
    },
    "nextjs": {
      "description": "Framework React de production avec rendu hybride, optimisation automatique et expérience de développement supérieure."
    },
    "mongodb": {
      "description": "Base de données NoSQL évolutive et flexible qui permet de gérer de gros volumes de données avec des schémas dynamiques."
    },
    "kotlin": {
      "description": "Langage moderne pour le développement Android natif avec syntaxe concise et interopérabilité avec Java."
    },
    "swift": {
      "description": "Langage puissant et intuitif d'Apple pour créer des applications iOS natives haute performance."
    },
    "railway": {
      "description": "Plateforme de déploiement moderne qui simplifie l'hébergement d'applications avec CI/CD automatique."
    },
    "figma": {
      "description": "Outil de design collaboratif pour créer des interfaces utilisateur et prototypes interactifs professionnels."
    },
    "claude": {
      "description": "Assistant IA pour le développement qui accélère la programmation avec suggestions intelligentes et génération de code."
    }
  },
  "Technologies": {
    "title": "Compétences Techniques",
    "description": "Mon expérience couvre du design UX/UI à l'infrastructure, me permettant de diriger des projets end-to-end avec une vision intégrale du développement.",
    "techCount": "Technologies",
    "yearsExp": "Années d'expérience",
    "additionalInfo": "Ma stack évolue constamment, explorant toujours de nouveaux outils qui me permettent de créer de meilleures solutions et de rester à jour avec les dernières tendances du développement.",
    "centerText": "Stack Tech",
    "frontend": {
      "title": "Frontend",
      "description": "Interfaces modernes et responsives avec React, Vue, Next.js pour des expériences utilisateur exceptionnelles."
    },
    "backend": {
      "title": "Backend",
      "description": "APIs robustes et évolutives utilisant Laravel, FastAPI, Python pour des systèmes d'entreprise solides."
    },
    "mobile": {
      "title": "Mobile",
      "description": "Développement natif avec Kotlin, Swift et multiplateforme avec technologies web pour des applications mobiles performantes."
    }
  },
  "ContactSection": {
    "title": "Contactez-moi",
    "description": "Vous avez un projet en tête ou voulez collaborer ? J'adorerais entendre votre idée et vous aider à la concrétiser.",
    "availableTitle": "Disponible pour projets",
    "availableDescription": "J'accepte actuellement de nouveaux projets et collaborations. N'hésitez pas à me contacter pour discuter de votre prochain développement."
  },
  "Actions": {
    "downloadCV": "Télécharger CV",
    "viewGitHub": "Voir GitHub"
  },
  "CVDialog": {
    "title": "CV non disponible",
    "description": "Bonjour ! Mon CV n'est pas encore disponible au téléchargement, mais il le sera très bientôt. Je vous invite à revenir bientôt pour l'obtenir.",
    "actionText": "Compris",
    "close": "Fermer"
  },
  "Certificates": {
    "title": "Certifications",
    "description": "En tant qu'diplômé en génie informatique, je suis passionné par l'apprentissage et l'amélioration constante. Voici quelques-uns des cours et certifications que j'ai complétés dans mon parcours de croissance professionnelle.",
    "pdfNotAvailable": "PDF non disponible pour ce certificat",
    "viewPdf": "PDF",
    "verify": "Vérifier",
    "certificates": {
      "claude-code": {
        "title": "Claude Code en Action",
        "provider": "Anthropic Education",
        "description": "Intégration d'assistant IA pour la programmation et optimisation du flux de travail"
      },
      "laravel": {
        "title": "Introduction à Laravel 9",
        "provider": "Platzi",
        "description": "Fondamentaux du développement avec framework PHP moderne"
      },
      "english": {
        "title": "Parcours d'Apprentissage Anglais",
        "provider": "Platzi",
        "description": "Certification complète de compétence en langue anglaise"
      },
      "wordpress": {
        "title": "Création de Plugins WordPress",
        "provider": "Platzi",
        "description": "Développement et architecture de plugins WordPress personnalisés"
      },
      "trading": {
        "title": "Analyse Technique pour Investissements",
        "provider": "Platzi",
        "description": "Cours intermédiaire d'investissement pour l'analyse de risque en bourse"
      },
      "html-css": {
        "title": "HTML et CSS Pratique",
        "provider": "Platzi",
        "description": "Fondamentaux pratiques de développement web HTML et CSS"
      },
      "dark-mode": {
        "title": "Design en Mode Sombre",
        "provider": "Platzi",
        "description": "Principes de design et implémentation du mode sombre"
      },
      "mobile-first": {
        "title": "Mobile First - Design Responsive",
        "provider": "Platzi",
        "description": "Méthodologie de design web responsive avec approche mobile-first"
      }
    }
  },
  "BestPractices": {
    "title": "Meilleures Pratiques de Développement",
    "subtitle": "Exemples réels de principes SOLID, Clean Code, Sécurité et Performance que j'applique dans mes projets pour créer du code maintenable et évolutif.",
    "description": "Ces pratiques garantissent que le code soit facile à maintenir, tester et étendre, résultant en applications plus robustes et équipes de développement plus productives.",
    "practices": "Principes",
    "selectFile": "Sélectionnez un fichier pour voir l'exemple",
    "files": {
      "singleResponsibility": "ResponsabiliteUnique.ts",
      "openClosed": "OuvertFerme.ts", 
      "dependencyInversion": "InversionDependances.ts",
      "meaningfulNames": "NomsSignificatifs.ts",
      "smallFunctions": "PetitesFonctions.ts",
      "avoidComments": "CodeAutoDocumente.ts",
      "inputValidation": "ValidationEntrees.ts",
      "secureSecrets": "GestionSecrets.ts",
      "avoidNPlusOne": "EviterNPlusUn.ts",
      "efficientCaching": "CacheEfficace.ts"
    },
    "examples": {
      "single-responsibility": {
        "title": "Principe de Responsabilité Unique",
        "description": "Chaque classe ne doit avoir qu'une seule raison de changer. Nous séparons les responsabilités en classes spécialisées."
      },
      "open-closed": {
        "title": "Principe Ouvert/Fermé",
        "description": "Les entités doivent être ouvertes à l'extension mais fermées à la modification. Nous utilisons des abstractions pour de nouvelles fonctionnalités."
      },
      "dependency-inversion": {
        "title": "Principe d'Inversion des Dépendances",
        "description": "Nous dépendons d'abstractions, pas d'implémentations concrètes. Cela facilite les tests et la flexibilité."
      },
      "meaningful-names": {
        "title": "Noms Significatifs",
        "description": "Utiliser des noms descriptifs et clairs qui expriment l'intention du code, éliminant le besoin de commentaires explicatifs."
      },
      "small-functions": {
        "title": "Petites Fonctions",
        "description": "Diviser les grandes fonctions en petites fonctions spécialisées qui accomplissent une seule tâche efficacement."
      },
      "avoid-comments": {
        "title": "Code Auto-Documenté",
        "description": "Écrire du code qui s'explique par lui-même grâce à des noms clairs et une structure logique, minimisant les commentaires."
      },
      "input-validation": {
        "title": "Validation des Entrées",
        "description": "Implémenter une validation et une désinfection rigoureuses des données d'entrée pour prévenir les vulnérabilités de sécurité."
      },
      "secure-secrets": {
        "title": "Gestion Sécurisée des Secrets",
        "description": "Gérer les identifiants et secrets de manière sécurisée en utilisant des variables d'environnement et services spécialisés."
      },
      "avoid-n-plus-1": {
        "title": "Éviter les Requêtes N+1",
        "description": "Optimiser les requêtes de base de données pour éviter le problème N+1 en utilisant des jointures et includes efficaces."
      },
      "efficient-caching": {
        "title": "Cache Efficace",
        "description": "Implémenter des stratégies de cache intelligentes pour améliorer les performances et réduire la charge sur la base de données."
      }
    }
  },
  "CodeExamples": {
    "singleResponsibility": {
      "before": "// ❌ Viole le principe de responsabilité unique\nclass UserService {\n  async createUser(userData: any) {\n    // Validation\n    if (!userData.email || !userData.password) {\n      throw new Error('Email and password are required');\n    }\n    \n    // Envoi d'email\n    await this.sendWelcomeEmail(userData.email);\n    \n    // Sauvegarde en base de données\n    const user = await db.users.create(userData);\n    \n    // Logging\n    console.log(`User created: ${user.id}`);\n    \n    return user;\n  }\n  \n  private async sendWelcomeEmail(email: string) {\n    // Logique d'envoi d'email\n  }\n}",
      "after": "// ✅ Respecte le principe de responsabilité unique\nclass UserService {\n  constructor(\n    private validator: UserValidator, // [!code ++]\n    private emailService: EmailService, // [!code ++]\n    private userRepository: UserRepository, // [!code ++]\n    private logger: Logger // [!code ++]\n  ) {}\n\n  async createUser(userData: any): Promise<User> {\n    this.validator.validate(userData); // [!code focus]\n    \n    const user = await this.userRepository.create(userData); // [!code focus]\n    \n    await this.emailService.sendWelcomeEmail(user.email); // [!code focus]\n    this.logger.log(`User created: ${user.id}`); // [!code focus]\n    \n    return user;\n  }\n}\n\nclass UserValidator { // [!code ++]\n  validate(userData: any): void { // [!code ++]\n    if (!userData.email || !userData.password) { // [!code ++]\n      throw new Error('Email and password are required'); // [!code ++]\n    } // [!code ++]\n  } // [!code ++]\n} // [!code ++]"
    },
    "openClosed": {
      "before": "// ❌ Viole le principe ouvert/fermé\nclass PaymentProcessor {\n  processPayment(amount: number, method: string) {\n    if (method === 'credit-card') {\n      return this.processCreditCard(amount);\n    } else if (method === 'paypal') {\n      return this.processPaypal(amount);\n    } else if (method === 'bank-transfer') {\n      return this.processBankTransfer(amount);\n    }\n    throw new Error('Unsupported payment method');\n  }\n  \n  private processCreditCard(amount: number) {\n    // Logique pour carte de crédit\n  }\n  \n  private processPaypal(amount: number) {\n    // Logique pour PayPal\n  }\n  \n  private processBankTransfer(amount: number) {\n    // Logique pour virement bancaire\n  }\n}",
      "after": "// ✅ Respecte le principe ouvert/fermé\ninterface PaymentMethod { // [!code ++]\n  process(amount: number): Promise<PaymentResult>; // [!code ++]\n} // [!code ++]\n\nclass CreditCardPayment implements PaymentMethod { // [!code ++]\n  async process(amount: number): Promise<PaymentResult> { // [!code ++]\n    // Logique spécifique pour carte de crédit // [!code ++]\n    return { success: true, transactionId: 'cc_123' }; // [!code ++]\n  } // [!code ++]\n} // [!code ++]\n\nclass PaypalPayment implements PaymentMethod { // [!code ++]\n  async process(amount: number): Promise<PaymentResult> { // [!code ++]\n    // Logique spécifique pour PayPal // [!code ++]\n    return { success: true, transactionId: 'pp_456' }; // [!code ++]\n  } // [!code ++]\n} // [!code ++]\n\nclass PaymentProcessor {\n  constructor(private paymentMethod: PaymentMethod) {} // [!code focus]\n  \n  async processPayment(amount: number): Promise<PaymentResult> { // [!code focus]\n    return await this.paymentMethod.process(amount); // [!code focus]\n  } // [!code focus]\n}"
    },
    "dependencyInversion": {
      "before": "// ❌ Viole le principe d'inversion des dépendances\nimport { MySQLDatabase } from './MySQLDatabase';\nimport { EmailProvider } from './EmailProvider';\n\nclass OrderService {\n  private database: MySQLDatabase;\n  private emailProvider: EmailProvider;\n  \n  constructor() {\n    this.database = new MySQLDatabase(); // Dépendance directe\n    this.emailProvider = new EmailProvider(); // Dépendance directe\n  }\n  \n  async createOrder(orderData: any) {\n    const order = await this.database.save(orderData);\n    await this.emailProvider.sendConfirmation(order.customerEmail);\n    return order;\n  }\n}",
      "after": "// ✅ Respecte le principe d'inversion des dépendances\ninterface Database { // [!code ++]\n  save(data: any): Promise<any>; // [!code ++]\n} // [!code ++]\n\ninterface NotificationService { // [!code ++]\n  sendConfirmation(email: string): Promise<void>; // [!code ++]\n} // [!code ++]\n\nclass OrderService {\n  constructor(\n    private database: Database, // Abstraction // [!code focus]\n    private notificationService: NotificationService // Abstraction // [!code focus]\n  ) {}\n  \n  async createOrder(orderData: any) {\n    const order = await this.database.save(orderData); // [!code focus]\n    await this.notificationService.sendConfirmation(order.customerEmail); // [!code focus]\n    return order;\n  }\n}\n\n// Implémentations concrètes // [!code ++]\nclass MySQLDatabase implements Database { // [!code ++]\n  async save(data: any): Promise<any> { // [!code ++]\n    // Implémentation spécifique MySQL // [!code ++]\n  } // [!code ++]\n} // [!code ++]\n\nclass EmailNotificationService implements NotificationService { // [!code ++]\n  async sendConfirmation(email: string): Promise<void> { // [!code ++]\n    // Implémentation spécifique email // [!code ++]\n  } // [!code ++]\n} // [!code ++]"
    },
    "meaningfulNames": {
      "before": "// ❌ Noms peu descriptifs\nclass Calc {\n  private data: any[] = [];\n  \n  process(d: any): number {\n    let r = 0;\n    let t = 0;\n    \n    for (let i = 0; i < d.length; i++) {\n      if (d[i].type === 1) {\n        r += d[i].amt * d[i].qty;\n        t += d[i].amt * d[i].qty * 0.15;\n      }\n    }\n    \n    return r + t;\n  }\n  \n  validate(x: any): boolean {\n    return x && x.amt > 0 && x.qty > 0;\n  }\n}",
      "after": "// ✅ Noms descriptifs et significatifs\nclass ProductPriceCalculator { // [!code ++]\n  private products: Product[] = []; // [!code ++]\n  \n  calculateTotalPrice(products: Product[]): number { // [!code ++]\n    let sousTotal = 0; // [!code ++]\n    let taxes = 0; // [!code ++]\n    \n    for (const produit of products) { // [!code ++]\n      if (produit.isActive) { // [!code ++]\n        const totalArticle = produit.price * produit.quantity; // [!code ++]\n        sousTotal += totalArticle; // [!code ++]\n        taxes += totalArticle * TAUX_TAXE; // [!code ++]\n      } // [!code ++]\n    } // [!code ++]\n    \n    return sousTotal + taxes; // [!code ++]\n  } // [!code ++]\n  \n  isValidProduct(produit: Product): boolean { // [!code ++]\n    return produit && produit.price > 0 && produit.quantity > 0; // [!code ++]\n  } // [!code ++]\n} // [!code ++]\n\nconst TAUX_TAXE = 0.15; // [!code ++]\n\ninterface Product { // [!code ++]\n  price: number; // [!code ++]\n  quantity: number; // [!code ++]\n  isActive: boolean; // [!code ++]\n} // [!code ++]"
    },
    "smallFunctions": {
      "before": "// ❌ Fonction large qui fait trop de choses\nasync function registerUser(userData: any) {\n  // Validation\n  if (!userData.email || !userData.email.includes('@')) {\n    throw new Error('Invalid email');\n  }\n  if (!userData.password || userData.password.length < 8) {\n    throw new Error('Password too short');\n  }\n  if (!userData.name || userData.name.trim().length === 0) {\n    throw new Error('Name is required');\n  }\n  \n  // Hash du mot de passe\n  const salt = await bcrypt.genSalt(10);\n  const hashedPassword = await bcrypt.hash(userData.password, salt);\n  \n  // Créer l'utilisateur\n  const user = await db.users.create({\n    email: userData.email.toLowerCase(),\n    password: hashedPassword,\n    name: userData.name.trim(),\n    createdAt: new Date()\n  });\n  \n  // Envoyer email de bienvenue\n  const emailTemplate = `Bienvenue ${user.name}! Merci de nous avoir rejoint.`;\n  await emailService.send(user.email, 'Bienvenue!', emailTemplate);\n  \n  // Journaliser l'activité\n  await db.logs.create({\n    action: 'USER_REGISTERED',\n    userId: user.id,\n    timestamp: new Date()\n  });\n  \n  return user;\n}",
      "after": "// ✅ Petites fonctions avec des responsabilités spécifiques\nasync function registerUser(userData: UserRegistrationData): Promise<User> {\n  await validateUserData(userData); // [!code focus]\n  \n  const hashedPassword = await hashPassword(userData.password); // [!code focus]\n  const user = await createUser(userData, hashedPassword); // [!code focus]\n  \n  await sendWelcomeEmail(user); // [!code focus]\n  await logUserRegistration(user.id); // [!code focus]\n  \n  return user;\n}\n\nasync function validateUserData(userData: UserRegistrationData): Promise<void> { // [!code ++]\n  validateEmail(userData.email); // [!code ++]\n  validatePassword(userData.password); // [!code ++]\n  validateName(userData.name); // [!code ++]\n} // [!code ++]\n\nfunction validateEmail(email: string): void { // [!code ++]\n  if (!email || !email.includes('@')) { // [!code ++]\n    throw new Error('Invalid email'); // [!code ++]\n  } // [!code ++]\n} // [!code ++]\n\nasync function hashPassword(password: string): Promise<string> { // [!code ++]\n  const salt = await bcrypt.genSalt(10); // [!code ++]\n  return bcrypt.hash(password, salt); // [!code ++]\n} // [!code ++]\n\nasync function createUser(userData: UserRegistrationData, hashedPassword: string): Promise<User> { // [!code ++]\n  return db.users.create({ // [!code ++]\n    email: userData.email.toLowerCase(), // [!code ++]\n    password: hashedPassword, // [!code ++]\n    name: userData.name.trim(), // [!code ++]\n    createdAt: new Date() // [!code ++]\n  }); // [!code ++]\n} // [!code ++]"
    },
    "avoidComments": {
      "before": "// ❌ Code nécessitant de nombreux commentaires pour être compris\nclass InventoryManager {\n  // Vérifier si le produit est disponible\n  check(p: Product, q: number): boolean {\n    // Obtenir le niveau de stock actuel\n    const s = this.getStock(p.id);\n    \n    // Vérifier si nous avons assez d'inventaire\n    // Il faut aussi tenir compte des articles réservés\n    const r = this.getReserved(p.id);\n    \n    // Disponible = stock - réservé\n    const a = s - r;\n    \n    // Retourner true si nous en avons assez\n    return a >= q;\n  }\n  \n  // Mettre à jour l'inventaire lors du passage de commande\n  update(pid: number, qty: number) {\n    // Obtenir les valeurs actuelles\n    const current = this.inventory[pid];\n    \n    // Soustraire la quantité\n    current.stock -= qty;\n    \n    // Ajouter aux réservés\n    current.reserved += qty;\n    \n    // Mettre à jour l'horodatage\n    current.lastUpdated = Date.now();\n  }\n}",
      "after": "// ✅ Code auto-documenté sans besoin de commentaires\nclass InventoryManager {\n  isProductAvailable(produit: Product, quantiteDemandee: number): boolean { // [!code ++]\n    const stockActuel = this.getCurrentStock(produit.id); // [!code ++]\n    const quantiteReservee = this.getReservedQuantity(produit.id); // [!code ++]\n    const quantiteDisponible = stockActuel - quantiteReservee; // [!code ++]\n    \n    return quantiteDisponible >= quantiteDemandee; // [!code ++]\n  } // [!code ++]\n  \n  reserveProductForOrder(productId: number, quantite: number): void { // [!code ++]\n    const enregistrementInventaire = this.getInventoryRecord(productId); // [!code ++]\n    \n    enregistrementInventaire.decreaseStock(quantite); // [!code ++]\n    enregistrementInventaire.increaseReserved(quantite); // [!code ++]\n    enregistrementInventaire.updateTimestamp(); // [!code ++]\n  } // [!code ++]\n  \n  private getCurrentStock(productId: number): number { // [!code ++]\n    return this.inventory[productId]?.stock ?? 0; // [!code ++]\n  } // [!code ++]\n  \n  private getReservedQuantity(productId: number): number { // [!code ++]\n    return this.inventory[productId]?.reserved ?? 0; // [!code ++]\n  } // [!code ++]\n  \n  private getInventoryRecord(productId: number): InventoryRecord { // [!code ++]\n    return this.inventory[productId]; // [!code ++]\n  } // [!code ++]\n}"
    },
    "inputValidation": {
      "before": "// ❌ Pas de validation d'entrée - vulnérable aux attaques\nclass AuthController {\n  async login(req: any, res: any) {\n    const { email, password } = req.body;\n    \n    // Rechercher l'utilisateur directement sans validation\n    const user = await db.query(\n      `SELECT * FROM users WHERE email = '${email}'`\n    );\n    \n    // Comparer le mot de passe en texte clair\n    if (user && user.password === password) {\n      // Créer un token sans validation\n      const token = jwt.sign({ id: user.id }, 'secret');\n      \n      res.json({ token, user });\n    } else {\n      res.status(401).json({ error: 'Invalid credentials' });\n    }\n  }\n  \n  async updateProfile(req: any, res: any) {\n    const { name, bio } = req.body;\n    \n    // Mettre à jour sans désinfecter\n    await db.query(\n      `UPDATE users SET name = '${name}', bio = '${bio}' WHERE id = ${req.user.id}`\n    );\n    \n    res.json({ success: true });\n  }\n}",
      "after": "// ✅ Avec validation et désinfection appropriées\nclass AuthController {\n  async login(req: Request, res: Response) { // [!code ++]\n    const { email, password } = this.validateLoginInput(req.body); // [!code ++]\n    \n    const user = await this.userRepository.findByEmail(email); // [!code ++]\n    \n    if (!user || !await this.passwordService.verify(password, user.hashedPassword)) { // [!code ++]\n      throw new UnauthorizedError('Invalid credentials'); // [!code ++]\n    } // [!code ++]\n    \n    const token = this.tokenService.generateSecureToken(user.id); // [!code ++]\n    \n    res.json({ // [!code ++]\n      token, // [!code ++]\n      user: this.sanitizeUserData(user) // [!code ++]\n    }); // [!code ++]\n  } // [!code ++]\n  \n  async updateProfile(req: Request, res: Response) { // [!code ++]\n    const userId = this.validateUserId(req.user.id); // [!code ++]\n    const { name, bio } = this.validateProfileInput(req.body); // [!code ++]\n    \n    const donneesDesinfectees = { // [!code ++]\n      name: this.sanitizer.cleanString(name), // [!code ++]\n      bio: this.sanitizer.cleanString(bio) // [!code ++]\n    }; // [!code ++]\n    \n    await this.userRepository.updateProfile(userId, donneesDesinfectees); // [!code ++]\n    \n    res.json({ success: true }); // [!code ++]\n  } // [!code ++]\n  \n  private validateLoginInput(body: any): LoginData { // [!code ++]\n    const schema = z.object({ // [!code ++]\n      email: z.string().email().max(255), // [!code ++]\n      password: z.string().min(8).max(128) // [!code ++]\n    }); // [!code ++]\n    \n    return schema.parse(body); // [!code ++]\n  } // [!code ++]\n}"
    },
    "secureSecrets": {
      "before": "// ❌ Secrets codés en dur et exposés\nclass DatabaseConfig {\n  private connectionString = \"postgresql://admin:password123@localhost:5432/mydb\";\n  \n  private jwtSecret = \"my-super-secret-key\";\n  \n  private apiKeys = {\n    stripe: \"sk_live_abc123def456ghi789\",\n    sendgrid: \"SG.xyz789.abc123def456\",\n    aws: \"AKIAIOSFODNN7EXAMPLE\"\n  };\n  \n  async connect() {\n    console.log(\"Connexion à:\", this.connectionString);\n    return pg.connect(this.connectionString);\n  }\n  \n  generateToken(payload: any) {\n    return jwt.sign(payload, this.jwtSecret, { expiresIn: '24h' });\n  }\n  \n  async sendEmail(to: string, subject: string, body: string) {\n    const client = new SendGrid(this.apiKeys.sendgrid);\n    return client.send({ to, subject, body });\n  }\n}",
      "after": "// ✅ Gestion sécurisée des secrets avec variables d'environnement\nclass DatabaseConfig {\n  private readonly connectionString: string; // [!code ++]\n  private readonly jwtSecret: string; // [!code ++]\n  private readonly apiKeys: ApiKeys; // [!code ++]\n  \n  constructor() { // [!code ++]\n    this.validateEnvironment(); // [!code ++]\n    \n    this.connectionString = this.buildConnectionString(); // [!code ++]\n    this.jwtSecret = this.getRequiredEnvVar('JWT_SECRET'); // [!code ++]\n    this.apiKeys = this.loadApiKeys(); // [!code ++]\n  } // [!code ++]\n  \n  async connect(): Promise<pg.Client> { // [!code ++]\n    return pg.connect(this.connectionString); // [!code ++]\n  } // [!code ++]\n  \n  generateToken(payload: any): string { // [!code ++]\n    if (!this.jwtSecret) { // [!code ++]\n      throw new Error('JWT secret not configured'); // [!code ++]\n    } // [!code ++]\n    \n    return jwt.sign(payload, this.jwtSecret, { expiresIn: '24h' }); // [!code ++]\n  } // [!code ++]\n  \n  private buildConnectionString(): string { // [!code ++]\n    const host = this.getRequiredEnvVar('DB_HOST'); // [!code ++]\n    const port = this.getRequiredEnvVar('DB_PORT'); // [!code ++]\n    const database = this.getRequiredEnvVar('DB_NAME'); // [!code ++]\n    const username = this.getRequiredEnvVar('DB_USER'); // [!code ++]\n    const password = this.getRequiredEnvVar('DB_PASSWORD'); // [!code ++]\n    \n    return `postgresql://${username}:${password}@${host}:${port}/${database}`; // [!code ++]\n  } // [!code ++]\n  \n  private getRequiredEnvVar(name: string): string { // [!code ++]\n    const value = process.env[name]; // [!code ++]\n    if (!value) { // [!code ++]\n      throw new Error(`Variable d'environnement requise manquante: ${name}`); // [!code ++]\n    } // [!code ++]\n    return value; // [!code ++]\n  } // [!code ++]\n}"
    },
    "avoidNPlusOne": {
      "before": "// ❌ Problème N+1: une requête par post\nclass PostService {\n  async getPostsWithAuthors(): Promise<PostWithAuthor[]> {\n    const posts = await db.posts.findMany({\n      where: { published: true },\n      orderBy: { createdAt: 'desc' }\n    });\n    \n    // Problème N+1! Une requête par post\n    const postsWithAuthors = [];\n    for (const post of posts) {\n      const author = await db.users.findUnique({\n        where: { id: post.authorId },\n        select: { id: true, name: true, email: true }\n      });\n      \n      postsWithAuthors.push({\n        ...post,\n        author\n      });\n    }\n    \n    return postsWithAuthors;\n  }\n  \n  async getPostsWithComments(): Promise<PostWithComments[]> {\n    const posts = await db.posts.findMany();\n    \n    // Encore N+1 pour les commentaires\n    for (const post of posts) {\n      post.comments = await db.comments.findMany({\n        where: { postId: post.id }\n      });\n    }\n    \n    return posts;\n  }\n}",
      "after": "// ✅ Requêtes optimisées avec jointures/includes\nclass PostService {\n  async getPostsWithAuthors(): Promise<PostWithAuthor[]> { // [!code ++]\n    return db.posts.findMany({ // [!code ++]\n      where: { published: true }, // [!code ++]\n      orderBy: { createdAt: 'desc' }, // [!code ++]\n      include: { // [!code focus]\n        author: { // [!code focus]\n          select: { // [!code focus]\n            id: true, // [!code focus]\n            name: true, // [!code focus]\n            email: true // [!code focus]\n          } // [!code focus]\n        } // [!code focus]\n      } // [!code focus]\n    }); // [!code ++]\n  } // [!code ++]\n  \n  async getPostsWithComments(): Promise<PostWithComments[]> { // [!code ++]\n    return db.posts.findMany({ // [!code ++]\n      include: { // [!code focus]\n        author: { // [!code focus]\n          select: { id: true, name: true } // [!code focus]\n        }, // [!code focus]\n        comments: { // [!code focus]\n          include: { // [!code focus]\n            author: { // [!code focus]\n              select: { id: true, name: true } // [!code focus]\n            } // [!code focus]\n          } // [!code focus]\n        } // [!code focus]\n      } // [!code focus]\n    }); // [!code ++]\n  } // [!code ++]\n  \n  async getPostsWithStats(): Promise<PostWithStats[]> { // [!code ++]\n    return db.posts.findMany({ // [!code ++]\n      include: { // [!code ++]\n        _count: { // [!code focus]\n          select: { // [!code focus]\n            comments: true, // [!code focus]\n            likes: true // [!code focus]\n          } // [!code focus]\n        } // [!code focus]\n      } // [!code ++]\n    }); // [!code ++]\n  } // [!code ++]\n}"
    },
    "efficientCaching": {
      "before": "// ❌ Pas de cache - requêtes coûteuses répétées\nclass ProductService {\n  async getProduct(id: number): Promise<Product> {\n    // Va toujours en base de données\n    const product = await db.products.findUnique({\n      where: { id },\n      include: {\n        category: true,\n        reviews: {\n          include: { user: true }\n        },\n        variants: true\n      }\n    });\n    \n    if (!product) {\n      throw new Error('Product not found');\n    }\n    \n    // Calcul coûteux qui se répète\n    const averageRating = product.reviews.reduce((sum, review) => \n      sum + review.rating, 0) / product.reviews.length;\n    \n    const totalStock = product.variants.reduce((sum, variant) => \n      sum + variant.stock, 0);\n    \n    return {\n      ...product,\n      averageRating,\n      totalStock,\n      isAvailable: totalStock > 0\n    };\n  }\n  \n  async getPopularProducts(): Promise<Product[]> {\n    // Requête lourde sans cache\n    return db.products.findMany({\n      where: { featured: true },\n      include: { reviews: true, category: true },\n      orderBy: { viewCount: 'desc' },\n      take: 10\n    });\n  }\n}",
      "after": "// ✅ Avec cache intelligent et stratifié\nclass ProductService {\n  constructor( // [!code ++]\n    private cache: CacheService, // [!code ++]\n    private db: DatabaseService // [!code ++]\n  ) {} // [!code ++]\n  \n  async getProduct(id: number): Promise<Product> { // [!code ++]\n    const cacheKey = `product:${id}`; // [!code ++]\n    \n    let product = await this.cache.get<Product>(cacheKey); // [!code focus]\n    if (product) { // [!code focus]\n      return product; // [!code focus]\n    } // [!code focus]\n    \n    product = await this.fetchProductWithCalculations(id); // [!code ++]\n    \n    await this.cache.set(cacheKey, product, { // [!code focus]\n      ttl: 3600, // 1 heure // [!code focus]\n      tags: ['product', `product-${id}`] // [!code focus]\n    }); // [!code focus]\n    \n    return product; // [!code ++]\n  } // [!code ++]\n  \n  async getPopularProducts(): Promise<Product[]> { // [!code ++]\n    const cacheKey = 'products:popular'; // [!code ++]\n    \n    let products = await this.cache.get<Product[]>(cacheKey); // [!code focus]\n    if (products) { // [!code focus]\n      return products; // [!code focus]\n    } // [!code focus]\n    \n    products = await this.db.products.findMany({ // [!code ++]\n      where: { featured: true }, // [!code ++]\n      include: { category: true }, // [!code ++]\n      orderBy: { viewCount: 'desc' }, // [!code ++]\n      take: 10 // [!code ++]\n    }); // [!code ++]\n    \n    await this.cache.set(cacheKey, products, { // [!code focus]\n      ttl: 1800, // 30 minutes // [!code focus]\n      tags: ['products', 'popular'] // [!code focus]\n    }); // [!code focus]\n    \n    return products; // [!code ++]\n  } // [!code ++]\n  \n  async invalidateProductCache(productId: number): Promise<void> { // [!code ++]\n    await this.cache.invalidateByTags([`product-${productId}`, 'popular']); // [!code ++]\n  } // [!code ++]\n}"
    }
  }
}